---
title: '60 Days 60 Hacks Retrospective'
date: '2015-07-09T18:59:23-05:00'
---

I’m finished with my learning project [#60days60hacks](https://twitter.com/search?src=typd&q=%2360Days60Hacks). The project is over, but the learning continues.

Some rough stats: I wrote twelve posts about Rails, ten posts about Vim, nine posts about Ruby, six posts about Git, six posts about bash, five posts about testing, four posts about general development, three posts about JavaScript, and one post about HTML/CSS. I created fifty-seven posts for [Today I Learned](http://til.hashrocket.com), and the dogfooding led to some feature development. I talked with people about my posts offline and on Twitter, receiving feedback and new ideas.

Committing to this project led to me work harder and learn more than I have in any contained period since I first learned to program.

When I first started coding, everything was hard. Manipulating text editors, the command line, and the browser each presented their own challenges. Stuff that seems really easy now, like setting up Git and my first Github repo, took hours. My first app wasn’t the Twitter-killer I planned, but I was still proud of it.

If you are learning to program, take heart: everybody starts out in this fog of confusion.

However, I was also standing on the shoulders of giants. By 2012 a lot of hard problems had been solved, abstracted away into massive frameworks like Ruby on Rails. I took advice from books and blogs on pure faith, told myself ‘I’ll figure this out someday’. Tools like `rails generate scaffold` are fine for getting off the ground, but they mask all the complexity underneath.

Graduating to a professional developer has brought a new kind of challenge— rejecting easy answers. Finding the answer is not good enough when it’s your job. You have to dig deeper and ask why a line of code works the way it does. Why was it written? What problem does it attempt to solve? Does it solve that problem? How can I make it solve my problem?

These questions are what I tried to address with this project. To take every Stack Overflow answer I found, internalize it, and then pry down two or three levels deeper. To ask whether a solution is the right one for me, beyond whether it works. Code that ‘works’ is a shaky idea. The best solutions are elegant, readable, and easy to change. That is professional code.

I owe a massive thank you to many people, but mostly to the Rocketeers of Chicago, who lent me endless inspiration as I composed my daily entries.

More to come!